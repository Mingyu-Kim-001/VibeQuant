"""
Base classes and types for VibeQuant agents.
"""

from typing import Dict, List, Optional, Any, TypedDict, Annotated
from dataclasses import dataclass, field
from enum import Enum
import operator


class WorkflowState(str, Enum):
    """States in the agent workflow."""
    IDLE = "idle"
    GENERATING_HYPOTHESIS = "generating_hypothesis"
    RESEARCHING = "researching"
    CODING = "coding"
    BACKTESTING = "backtesting"
    EVALUATING = "evaluating"
    ITERATING = "iterating"
    COMPLETE = "complete"
    ERROR = "error"


@dataclass
class Hypothesis:
    """A trading hypothesis generated by the Insight Agent."""
    id: str
    statement: str
    rationale: str
    category: str
    data_requirements: List[str]
    expected_characteristics: Dict[str, Any]
    priority_score: float = 0.5


@dataclass
class StrategyCode:
    """Generated strategy code from the Research Agent."""
    strategy_id: str
    hypothesis_id: str
    name: str
    code: str
    parameters: Dict[str, Any]
    description: str
    required_data: List[str]


@dataclass
class BacktestOutput:
    """Output from the Backtest Agent."""
    strategy_id: str
    success: bool
    error_message: Optional[str] = None
    metrics: Optional[Dict[str, float]] = None
    equity_curve: Optional[List[float]] = None
    trade_count: int = 0


@dataclass
class FeedbackOutput:
    """Output from the Feedback Agent."""
    strategy_id: str
    passed: bool
    score: float
    feedback: List[str]
    failure_reasons: List[str]
    improvement_suggestions: List[str]
    should_iterate: bool
    learnings: List[str]


class AgentState(TypedDict):
    """
    Shared state for the LangGraph workflow.
    This is passed between all agents.
    """
    # Workflow control
    iteration: int
    max_iterations: int
    workflow_state: str
    error_message: Optional[str]

    # Current work items
    current_hypothesis: Optional[Dict]
    current_strategy: Optional[Dict]
    current_backtest_results: Optional[Dict]
    current_feedback: Optional[Dict]

    # Memory context
    memory_context: Dict[str, Any]

    # History (accumulated across iterations)
    hypotheses_generated: Annotated[List[Dict], operator.add]
    strategies_coded: Annotated[List[Dict], operator.add]
    backtests_run: Annotated[List[Dict], operator.add]
    feedbacks_given: Annotated[List[Dict], operator.add]

    # Results
    successful_strategies: Annotated[List[Dict], operator.add]
    failed_strategies: Annotated[List[Dict], operator.add]

    # Metadata
    run_id: str
    started_at: str


@dataclass
class AgentOutput:
    """Standard output format for all agents."""
    success: bool
    agent_name: str
    output: Any
    error: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


# Passing criteria for strategies
# Note: Alphas should be uncorrelated to EACH OTHER, not necessarily to SPY
PASSING_CRITERIA = {
    "min_sharpe_ratio": 0.5,
    "min_trades": 20,
    "min_profit_factor": 1.0,
}


def check_passing_criteria(metrics: Dict[str, float]) -> tuple[bool, List[str]]:
    """
    Check if strategy metrics meet passing criteria.

    Args:
        metrics: Backtest metrics dictionary

    Returns:
        Tuple of (passed, list of failure reasons)
    """
    failures = []

    if metrics.get("sharpe_ratio", 0) < PASSING_CRITERIA["min_sharpe_ratio"]:
        failures.append(
            f"Sharpe ratio {metrics.get('sharpe_ratio', 0):.2f} "
            f"< {PASSING_CRITERIA['min_sharpe_ratio']}"
        )

    if metrics.get("num_trades", 0) < PASSING_CRITERIA["min_trades"]:
        failures.append(
            f"Number of trades {metrics.get('num_trades', 0)} "
            f"< {PASSING_CRITERIA['min_trades']}"
        )

    if metrics.get("profit_factor", 0) < PASSING_CRITERIA["min_profit_factor"]:
        failures.append(
            f"Profit factor {metrics.get('profit_factor', 0):.2f} "
            f"< {PASSING_CRITERIA['min_profit_factor']}"
        )

    return len(failures) == 0, failures
